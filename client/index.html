<!DOCTYPE html>
<html>
<head>
	<title>Path Search</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">
	<!-- Latest compiled and minified JavaScript -->
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
	<!-- Official Scrabble Player's Dictionary -->
	<script src="dictionary.js"></script>
	<script type="text/javascript">

	$(document).ready(function(){
		$('#pathSearch').submit(function() {
			$('#result').html('');
			$('#errors').html('');
			WordLadder($('#startWord').val(), $('#endWord').val());
			$('#startWord').val('');
			$('#endWord').val('');
			return false;
		});
	});

	// main problem-solving function
	function WordLadder(startWord, endWord) {
		var success = false;

		// input errors
		if (startWord.length != endWord.length) { return writeHTML('errors','text-danger','Words must be the same length'); }
		if (!(startWord.toLowerCase() in dictionary)) { return writeHTML('errors','text-danger','"' + startWord + '"' + ' was not found in the dictionary.'); }
		if (!(endWord.toLowerCase() in dictionary)) { return writeHTML('errors','text-danger','"' + endWord + '"' + ' was not found in the dictionary.'); }

		// create resource object to push used words
		var resource = {};

		// create queue for BFS and enqueue startWord
		var queue = new Queue();
		queue.enqueue(new graphNode(startWord));

		// BFS
		while (!queue.isEmpty()) {
			var node = queue.dequeue();

			// return if endWord is reached
			if (node.word == endWord.toLowerCase()) {
				writeHTML('result', 'text-success', node.path());
				success = true;
				continue;
			}

			if (!(node.word in resource)) {
				// add node word to resource object
				resource[node.word] = null;

				// create and enqueue adjacent words
				var children = graphExtend(node.word);

				for (var i=0; i<children.length; i++) {
					var child = new graphNode(children[i]);
					child.parent = node; // set child's parent
					node.adjacent.push(child); // update array of parent's adjacent nodes
					queue.enqueue(child);
				}
			}
		}

		// return only if search was unsuccessful
		if (!success) { return writeHTML('result', 'text-danger', 'No paths exist between these two words.'); }
	}

	// substitute each character in the word all characters
	function graphExtend (word) {
		var result = [];

		for (var i=0; i<word.length; i++) {
			for (var ch=97; ch<121; ch++) {
				var child = word.substring(0,i) + String.fromCharCode(ch) + word.substring(i+1);
				if (child != word && child in dictionary) { result.push(child); }
			}
		}

		return result;
	}

	// graph item
	var graphNode = function(word) {
		this.word = word;
		this.parent = null;
		this.adjacent = [];

		// print path by traversing backwards
		this.path = function() {
			var path = [];
			var result = '';
			var current = this.parent;

			while(current) {
				path.push(current.word);
				current = current.parent;
			}

			for (var i=path.length-1; i>=0; i--) {
				result += path[i];
				result += ' -> ';
			}

			return result + this.word;
		};
	};

	// queue item
	var queueNode = function(item) {
		this.item = item;
		this.next = null;
	};

	// Queue class. enqueue to last, dequeue from first
	var Queue = function() {
		var first = null;
		var last = null;

		this.enqueue = function(item) {
			if (!first) {
				last = new queueNode(item);
				first = last;
			} else {
				last.next = new queueNode(item);
				last = last.next;
			}
		};

		this.dequeue = function() {
			if (first) {
				var item = first.item;

				first = first.next;
				if (!first) { last = null; } // if empty, empty queue

				return item;
			}
			return null;
		};

		this.isEmpty = function() {
			return (!first);
		};
	};

	// function to write HTML content
	function writeHTML(id, style, string) {
		$('#' + id).append('<h4 class="' + style + '">'+ string + '</h4>');
	}

	</script>
</head>
<body>
	<div class="container">
		<div class="row">
			<div class="col-xs-6">
				<h4>Construct paths from a start word to an end word where intermediate words differ by a character from their adjacent words.</h4>
				<h4>Enter two words of the same length. The algorithm references against <a href="http://www.freescrabbledictionary.com/sowpods/download/sowpods.txt">SOWPODS (Europe Scrabble Word List)</a>. The algorithm will draw paths that avoid circling back to a word that have already been used at a branching point.</h4>
				<h4>View source for the code.</h4>
				<h4>Examples:</h4>
				<ul>
					<li>positive test case: "tame", "rent"</li>
					<li>negative test case: "bridal", "batter"</li>
					<li>corner case: "dog", "dog"</li>
					<li>corner case: "sent", "rent"</li>
				</ul>

				<div id="errors"></div>

				<div class="form-group">
					<label>Start Word:</label>
					<input class="form-control" id="startWord" type="text">
				</div>

				<div class="form-group">
					<label>End Word:</label>
					<input class="form-control" id="endWord" type="text">
				</div>

				<form id="pathSearch">
					<input class="form-control" type="submit">
				</form>
			</div>

			<div id="result" class="col-xs-6"></div>
		</div>
	</div>
</body>
</html>